"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_pages_play_tsx",{

/***/ "./src/utils/user-actions/touchEvents.ts":
/*!***********************************************!*\
  !*** ./src/utils/user-actions/touchEvents.ts ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTouchHandlers: function() { return /* binding */ useTouchHandlers; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _store_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../store/index */ \"./src/store/index.ts\");\n/* harmony import */ var _store_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../store/hooks */ \"./src/store/hooks.ts\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/debounce */ \"./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nfunction useTouchHandlers(setSquareState, isBeingDragged, initialSquare, glowingElements) {\n    // redux state extraction \n    const squareBeingDragged = (0,_store_hooks__WEBPACK_IMPORTED_MODULE_2__.useAppSelector)((state)=>state.candyCrush.squareBeingDragged);\n    const squareBeingDraggedOver = (0,_store_hooks__WEBPACK_IMPORTED_MODULE_2__.useAppSelector)((state)=>state.candyCrush.squareBeingDraggedOver);\n    const dispatch = (0,_store_hooks__WEBPACK_IMPORTED_MODULE_2__.useAppDispatch)();\n    const handleTouchStart = (e)=>{\n        setSquareState((prevState)=>({\n                ...prevState,\n                isBeingDragged: true\n            }));\n        const touch = e.changedTouches[0]; // Get the first touch point\n        const target = document.elementFromPoint(touch.clientX, touch.clientY); // Get the element under the touch\n        if (target instanceof HTMLImageElement) {\n            const candyId = parseInt(target.getAttribute(\"candy-id\") || \"0\", 10);\n            target.style.boxShadow = \"0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff\";\n            target.style.transform = \"scale(1.3)\"; // Grow the size by 10%\n            setSquareState((prevState)=>({\n                    ...prevState,\n                    initialSquare: candyId\n                })) // reset initial square\n            ;\n            dispatch((0,_store_index__WEBPACK_IMPORTED_MODULE_1__.dragStart)(target));\n        }\n    };\n    const handleDebouncedTouchMove = lodash_debounce__WEBPACK_IMPORTED_MODULE_3___default()((e)=>{\n    //  touch move handling logic goes here\n    }, 100); // Adjust the debounce delay as needed\n    let lastTouchX = 0;\n    let lastTouchY = 0;\n    let lastTouchTime = 0;\n    const threshold = 1.5; // Adjust as needed based on testing and user feedback\n    const handleTouchMove = (e)=>{\n        handleDebouncedTouchMove(e); // Invoke the debounced touch move handler\n        const touch = e.changedTouches[0]; // Get the first touch point\n        const target = document.elementFromPoint(touch.clientX, touch.clientY); // Get the element under the touch\n        const touchX = touch.clientX;\n        const touchY = touch.clientY;\n        const currentTime = Date.now();\n        const timeDiff = currentTime - lastTouchTime;\n        const distanceX = Math.abs(touchX - lastTouchX);\n        const distanceY = Math.abs(touchY - lastTouchY);\n        const isFastDrag = timeDiff > 0 && (distanceX / timeDiff > threshold || distanceY / timeDiff > threshold);\n        // If the drag is fast, clear the box-shadow of all candy images\n        if (isFastDrag) {\n            const candyImages = document.querySelectorAll(\"img[candy-id]\");\n            // Type assertion to inform TypeScript that 'candyImages' is a NodeList of HTMLImageElement\n            candyImages.forEach((img)=>{\n                if (img instanceof HTMLImageElement && img !== squareBeingDragged) {\n                    img.style.boxShadow = \"\";\n                }\n            });\n        }\n        lastTouchX = touchX;\n        lastTouchY = touchY;\n        lastTouchTime = currentTime;\n        if (target instanceof HTMLImageElement) {\n            const candyId = parseInt(target.getAttribute(\"candy-id\") || \"0\", 10);\n            const squareBeingDraggedInitialPosition = squareBeingDragged.getAttribute(\"candy-id\");\n            const positionX = squareBeingDraggedOver === null || squareBeingDraggedOver === void 0 ? void 0 : squareBeingDraggedOver.positionX;\n            const positionY = squareBeingDraggedOver === null || squareBeingDraggedOver === void 0 ? void 0 : squareBeingDraggedOver.positionY;\n            const squareBeingDraggedOverPosition = positionY * 8 + positionX;\n            // Apply glow effect only to the dragged image\n            // Check for adjacency in all directions (including diagonals)\n            // Check for adjacency in all directions (including diagonals)\n            if (Math.abs(squareBeingDraggedInitialPosition - squareBeingDraggedOverPosition) === 1 || // check horizontal adjacency\n            Math.abs(squareBeingDraggedInitialPosition - squareBeingDraggedOverPosition) === 8 || // Check for vertical adjacency\n            Math.abs(squareBeingDraggedInitialPosition - squareBeingDraggedOverPosition) === 7 || // Check for diagonal adjacency (top-left/bottom-right)\n            Math.abs(squareBeingDraggedInitialPosition - squareBeingDraggedOverPosition) === 9 // Check for diagonal adjacency (top-right/bottom-left)\n            ) {\n                if (!glowingElements.some((element)=>parseInt(element.getAttribute(\"candy-id\") || \"0\", 10) === candyId)) {\n                    // Add the target element only if its candy-id doesn't exist in the array\n                    if (target !== squareBeingDragged) {\n                        setSquareState((prevState)=>({\n                                ...prevState,\n                                glowingElements: [\n                                    ...prevState.glowingElements,\n                                    target\n                                ]\n                            }));\n                    // setGlowingElements((prevElements) => [...prevElements, target]);\n                    }\n                }\n                if (glowingElements.length > 1) {\n                    if (squareBeingDraggedOverPosition !== squareBeingDraggedInitialPosition) {\n                        const updatedElements = glowingElements.slice(1); // Remove the first element\n                        glowingElements[0].style.boxShadow = \"\"; // Remove glow effect from the last element\n                        setSquareState((prevState)=>({\n                                ...prevState,\n                                glowingElements: updatedElements\n                            }));\n                    }\n                }\n                if (squareBeingDraggedOverPosition !== squareBeingDraggedInitialPosition && target !== squareBeingDragged) {\n                    target.style.boxShadow = isBeingDragged ? \"0 0 10px #ffffe0, 0 0 20px #ffffe0, 0 0 30px #ffffe0, 0 0 40px #ffffe0\" : \"\"; // Apply glow effect\n                } else {\n                    target.style.boxShadow = \"\";\n                }\n                if (!isBeingDragged) {\n                    target.style.boxShadow = \"\";\n                }\n                if (target === squareBeingDragged) {\n                    if (glowingElements[0]) {\n                        glowingElements[0].style.boxShadow = \"\";\n                    }\n                }\n            } else if (candyId !== initialSquare) {\n                target.style.boxShadow = \"\"; // Remove glow effect if not adjacent\n                target.style.transform = \"\"; // Reset size\n            } else {\n                target.style.boxShadow = \"0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff\";\n            }\n            dispatch((0,_store_index__WEBPACK_IMPORTED_MODULE_1__.dragOver)({\n                positionX: candyId % 8,\n                positionY: Math.floor(candyId / 8)\n            }));\n            setSquareState((prevState)=>({\n                    ...prevState,\n                    draggedOverSquare: target\n                }));\n        }\n    };\n    const handleTouchEnd = (e)=>{\n        e.preventDefault(); // Prevent default touch behavior\n        const touch = e.changedTouches[0]; // Get the first touch point\n        const target = document.elementFromPoint(touch.clientX, touch.clientY); // Get the element under the touch\n        if (target instanceof HTMLImageElement) {\n            target.style.boxShadow = \"\"; // Remove the box shadow\n            target.style.transform = \"\"; // Grow the size by 10%    console.log('it works', isBeingDragged)\n            const touchTarget = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n            if (touchTarget) {\n                target.style.boxShadow = \"\"; // Remove the box shadow\n                target.style.transform = \"\"; // Grow the size by 10%    console.log('it works', isBeingDragged)      dispatch(dragDrop(touchTarget));\n                dispatch((0,_store_index__WEBPACK_IMPORTED_MODULE_1__.dragDrop)(touchTarget));\n                setSquareState((prevState)=>({\n                        ...prevState,\n                        isBeingDragged: false\n                    }));\n            }\n            squareBeingDragged.style.boxShadow = \"\";\n            squareBeingDragged.style.transform = \"\";\n            glowingElements[0].style.boxShadow = \"\"; // Remove the box shadow\n            glowingElements[0].style.transform = \"\"; // Grow the size by 10%\n            dispatch((0,_store_index__WEBPACK_IMPORTED_MODULE_1__.dragEnd)());\n            setSquareState((prevState)=>({\n                    ...prevState,\n                    isBeingDragged: false\n                }));\n        }\n    };\n    const handlePointerLeave = (e)=>{\n        e.preventDefault(); // Prevent default touch behavior\n        const target = e.target;\n        target.style.boxShadow = \"\"; // Remove the box shadow\n        target.style.transform = \"\"; // Grow the size by 10%    console.log('it works', isBeingDragged)      dispatch(dragDrop(touchTarget));\n        if (glowingElements[0]) {\n            glowingElements[0].style.boxShadow = \"\"; // Remove the box shadow\n            glowingElements[0].style.transform = \"\"; // Grow the size by 10%\n        }\n        dispatch((0,_store_index__WEBPACK_IMPORTED_MODULE_1__.dragEnd)());\n        setSquareState((prevState)=>({\n                ...prevState,\n                isBeingDragged: false\n            }));\n    };\n    return {\n        handleTouchStart,\n        handleTouchMove,\n        handleTouchEnd,\n        handlePointerLeave\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFBRTtZQUN2QkEsZUFBZSxDQUFDLEVBQUUsQ0FBQ29CLEtBQUssQ0FBQ0MsU0FBUyxHQUFHLElBQUksd0JBQXdCO1lBQ2pFckIsZUFBZSxDQUFDLEVBQUUsQ0FBQ29CLEtBQUssQ0FBQ0UsU0FBUyxHQUFHLElBQUksdUJBQXVCO1FBQ2hFO1FBQ0FqQixTQUFTZixxREFBT0E7UUFDaEJPLGVBQWVXLENBQUFBLFlBQVk7Z0JBQ3ZCLEdBQUdBLFNBQVM7Z0JBQ1pWLGdCQUFlO1lBQUs7SUFDeEI7SUFFQSxPQUFPO1FBQ1BRO1FBQ0FzQjtRQUNBMkI7UUFDQUc7SUFBa0I7QUFFMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3VzZXItYWN0aW9ucy90b3VjaEV2ZW50cy50cz8xNmZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGRyYWdEcm9wLCBkcmFnRW5kLCBkcmFnU3RhcnQsIGRyYWdPdmVyIH0gZnJvbSBcIi4uLy4uL3N0b3JlL2luZGV4XCI7XG5pbXBvcnQgeyB1c2VBcHBEaXNwYXRjaCwgdXNlQXBwU2VsZWN0b3IgfSBmcm9tIFwiLi4vLi4vc3RvcmUvaG9va3NcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2gvZGVib3VuY2UnO1xuXG5pbnRlcmZhY2UgU3F1YXJlU3RhdGUge1xuICAgIGluaXRpYWxTcXVhcmU6IG51bWJlcjtcbiAgICBkcmFnZ2VkT3ZlclNxdWFyZTogYW55O1xuICAgIGlzQmVpbmdEcmFnZ2VkOiBib29sZWFuO1xuICAgIGdsb3dpbmdFbGVtZW50czogSFRNTEltYWdlRWxlbWVudFtdO1xuICAgIHBsYXllZFNvdW5kRm9yRWxlbWVudDogU2V0PG51bWJlcj47XG4gICAgfTtcblxuICAgIGV4cG9ydCBmdW5jdGlvbiB1c2VUb3VjaEhhbmRsZXJzKFxuICAgICAgICBzZXRTcXVhcmVTdGF0ZTogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248U3F1YXJlU3RhdGU+PixcbiAgICAgICAgaXNCZWluZ0RyYWdnZWQ6IGJvb2xlYW4sXG4gICAgICAgIGluaXRpYWxTcXVhcmU6IG51bWJlcixcbiAgICAgICAgZ2xvd2luZ0VsZW1lbnRzOiBIVE1MSW1hZ2VFbGVtZW50W11cbiAgICApIHtcblxuICAgIC8vIHJlZHV4IHN0YXRlIGV4dHJhY3Rpb24gXG4gICAgY29uc3Qgc3F1YXJlQmVpbmdEcmFnZ2VkID0gdXNlQXBwU2VsZWN0b3IoKHN0YXRlKSA9PiBzdGF0ZS5jYW5keUNydXNoLnNxdWFyZUJlaW5nRHJhZ2dlZCk7XG4gICAgY29uc3Qgc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlciA9IHVzZUFwcFNlbGVjdG9yKChzdGF0ZSkgPT4gc3RhdGUuY2FuZHlDcnVzaC5zcXVhcmVCZWluZ0RyYWdnZWRPdmVyKTtcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlQXBwRGlzcGF0Y2goKTtcblxuICAgIGNvbnN0IGhhbmRsZVRvdWNoU3RhcnQgPSAoZTogUmVhY3QuVG91Y2hFdmVudDxIVE1MSW1hZ2VFbGVtZW50PikgPT4ge1xuXG4gICAgICAgIHNldFNxdWFyZVN0YXRlKHByZXZTdGF0ZSA9PiAoe1xuICAgICAgICAgICAgLi4ucHJldlN0YXRlLFxuICAgICAgICAgICAgaXNCZWluZ0RyYWdnZWQ6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB0b3VjaCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07IC8vIEdldCB0aGUgZmlyc3QgdG91Y2ggcG9pbnRcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTsgLy8gR2V0IHRoZSBlbGVtZW50IHVuZGVyIHRoZSB0b3VjaFxuICAgIFxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkgeyAvLyBFbnN1cmUgaXQncyBhbiBpbWFnZSBlbGVtZW50XG4gICAgXG4gICAgICAgICAgICBjb25zdCBjYW5keUlkID0gcGFyc2VJbnQodGFyZ2V0LmdldEF0dHJpYnV0ZSgnY2FuZHktaWQnKSB8fCAnMCcsIDEwKTtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5ib3hTaGFkb3cgPSBcIjAgMCAxMHB4ICMwMGZmZmYsIDAgMCAyMHB4ICMwMGZmZmYsIDAgMCAzMHB4ICMwMGZmZmYsIDAgMCA0MHB4ICMwMGZmZmZcIjtcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlKDEuMylcIjsgLy8gR3JvdyB0aGUgc2l6ZSBieSAxMCVcbiAgICAgICAgICAgIHNldFNxdWFyZVN0YXRlKHByZXZTdGF0ZSA9PiAoe1xuICAgICAgICAgICAgLi4ucHJldlN0YXRlLFxuICAgICAgICAgICAgaW5pdGlhbFNxdWFyZTpjYW5keUlkXG4gICAgICAgICAgICB9KSkgLy8gcmVzZXQgaW5pdGlhbCBzcXVhcmVcbiAgICAgICAgICAgIGRpc3BhdGNoKGRyYWdTdGFydCh0YXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZURlYm91bmNlZFRvdWNoTW92ZSA9IGRlYm91bmNlKChlKSA9PiB7XG4gICAgICAgIC8vICB0b3VjaCBtb3ZlIGhhbmRsaW5nIGxvZ2ljIGdvZXMgaGVyZVxuICAgICAgICB9LCAxMDApOyAvLyBBZGp1c3QgdGhlIGRlYm91bmNlIGRlbGF5IGFzIG5lZWRlZFxuICAgIFxuICAgICAgICBsZXQgbGFzdFRvdWNoWCA9IDA7XG4gICAgICAgIGxldCBsYXN0VG91Y2hZID0gMDtcbiAgICAgICAgbGV0IGxhc3RUb3VjaFRpbWUgPSAwO1xuICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSAxLjU7IC8vIEFkanVzdCBhcyBuZWVkZWQgYmFzZWQgb24gdGVzdGluZyBhbmQgdXNlciBmZWVkYmFja1xuICAgIFxuICAgICAgICBjb25zdCBoYW5kbGVUb3VjaE1vdmUgPSAoZTogUmVhY3QuVG91Y2hFdmVudDxIVE1MSW1hZ2VFbGVtZW50PikgPT4ge1xuICAgICAgICBoYW5kbGVEZWJvdW5jZWRUb3VjaE1vdmUoZSk7IC8vIEludm9rZSB0aGUgZGVib3VuY2VkIHRvdWNoIG1vdmUgaGFuZGxlclxuICAgIFxuICAgICAgICBjb25zdCB0b3VjaCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07IC8vIEdldCB0aGUgZmlyc3QgdG91Y2ggcG9pbnRcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTsgLy8gR2V0IHRoZSBlbGVtZW50IHVuZGVyIHRoZSB0b3VjaFxuICAgICAgICBjb25zdCB0b3VjaFggPSB0b3VjaC5jbGllbnRYO1xuICAgICAgICBjb25zdCB0b3VjaFkgPSB0b3VjaC5jbGllbnRZO1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHRpbWVEaWZmID0gY3VycmVudFRpbWUgLSBsYXN0VG91Y2hUaW1lO1xuICAgICAgICBjb25zdCBkaXN0YW5jZVggPSBNYXRoLmFicyh0b3VjaFggLSBsYXN0VG91Y2hYKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VZID0gTWF0aC5hYnModG91Y2hZIC0gbGFzdFRvdWNoWSk7XG4gICAgICAgIGNvbnN0IGlzRmFzdERyYWcgPSB0aW1lRGlmZiA+IDAgJiYgKGRpc3RhbmNlWCAvIHRpbWVEaWZmID4gdGhyZXNob2xkIHx8IGRpc3RhbmNlWSAvIHRpbWVEaWZmID4gdGhyZXNob2xkKTtcbiAgICBcbiAgICAgICAgLy8gSWYgdGhlIGRyYWcgaXMgZmFzdCwgY2xlYXIgdGhlIGJveC1zaGFkb3cgb2YgYWxsIGNhbmR5IGltYWdlc1xuICAgICAgICBpZiAoaXNGYXN0RHJhZykge1xuICAgICAgICAgICAgY29uc3QgY2FuZHlJbWFnZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbWdbY2FuZHktaWRdJyk7XG4gICAgXG4gICAgICAgICAgICAvLyBUeXBlIGFzc2VydGlvbiB0byBpbmZvcm0gVHlwZVNjcmlwdCB0aGF0ICdjYW5keUltYWdlcycgaXMgYSBOb2RlTGlzdCBvZiBIVE1MSW1hZ2VFbGVtZW50XG4gICAgICAgICAgICBjYW5keUltYWdlcy5mb3JFYWNoKChpbWcpID0+IHtcbiAgICAgICAgICAgIGlmIChpbWcgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ICYmIGltZyAhPT0gc3F1YXJlQmVpbmdEcmFnZ2VkKSB7ICAgICAgICAvLyBUeXBlIGFzc2VydGlvbiB0byBpbmZvcm0gVHlwZVNjcmlwdCB0aGF0ICdpbWcnIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnRcbiAgICAgICAgICAgICAgICBpbWcuc3R5bGUuYm94U2hhZG93ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBsYXN0VG91Y2hYID0gdG91Y2hYO1xuICAgICAgICBsYXN0VG91Y2hZID0gdG91Y2hZO1xuICAgICAgICBsYXN0VG91Y2hUaW1lID0gY3VycmVudFRpbWU7XG4gICAgXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7IC8vIEVuc3VyZSBpdCdzIGFuIGltYWdlIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGNhbmR5SWQgPSBwYXJzZUludCh0YXJnZXQuZ2V0QXR0cmlidXRlKCdjYW5keS1pZCcpIHx8ICcwJywgMTApO1xuICAgIFxuICAgICAgICAgICAgY29uc3Qgc3F1YXJlQmVpbmdEcmFnZ2VkSW5pdGlhbFBvc2l0aW9uID0gKHNxdWFyZUJlaW5nRHJhZ2dlZCBhcyBhbnkpLmdldEF0dHJpYnV0ZSgnY2FuZHktaWQnKTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uWCA9IChzcXVhcmVCZWluZ0RyYWdnZWRPdmVyIGFzIGFueSk/LnBvc2l0aW9uWDtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uWSA9IChzcXVhcmVCZWluZ0RyYWdnZWRPdmVyIGFzIGFueSk/LnBvc2l0aW9uWTtcbiAgICAgICAgICAgIGNvbnN0IHNxdWFyZUJlaW5nRHJhZ2dlZE92ZXJQb3NpdGlvbiA9IHBvc2l0aW9uWSAqIDggKyBwb3NpdGlvblg7XG4gICAgXG4gICAgICAgICAgICAvLyBBcHBseSBnbG93IGVmZmVjdCBvbmx5IHRvIHRoZSBkcmFnZ2VkIGltYWdlXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgYWRqYWNlbmN5IGluIGFsbCBkaXJlY3Rpb25zIChpbmNsdWRpbmcgZGlhZ29uYWxzKVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFkamFjZW5jeSBpbiBhbGwgZGlyZWN0aW9ucyAoaW5jbHVkaW5nIGRpYWdvbmFscylcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgTWF0aC5hYnMoc3F1YXJlQmVpbmdEcmFnZ2VkSW5pdGlhbFBvc2l0aW9uIC0gc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlclBvc2l0aW9uKSA9PT0gMSB8fCAvLyBjaGVjayBob3Jpem9udGFsIGFkamFjZW5jeVxuICAgICAgICAgICAgTWF0aC5hYnMoc3F1YXJlQmVpbmdEcmFnZ2VkSW5pdGlhbFBvc2l0aW9uIC0gc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlclBvc2l0aW9uKSA9PT0gOCB8fCAvLyBDaGVjayBmb3IgdmVydGljYWwgYWRqYWNlbmN5XG4gICAgICAgICAgICAoTWF0aC5hYnMoc3F1YXJlQmVpbmdEcmFnZ2VkSW5pdGlhbFBvc2l0aW9uIC0gc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlclBvc2l0aW9uKSA9PT0gNykgfHwgLy8gQ2hlY2sgZm9yIGRpYWdvbmFsIGFkamFjZW5jeSAodG9wLWxlZnQvYm90dG9tLXJpZ2h0KVxuICAgICAgICAgICAgKE1hdGguYWJzKHNxdWFyZUJlaW5nRHJhZ2dlZEluaXRpYWxQb3NpdGlvbiAtIHNxdWFyZUJlaW5nRHJhZ2dlZE92ZXJQb3NpdGlvbikgPT09IDkpIC8vIENoZWNrIGZvciBkaWFnb25hbCBhZGphY2VuY3kgKHRvcC1yaWdodC9ib3R0b20tbGVmdClcbiAgICBcbiAgICAgICAgICAgICkge1xuICAgIFxuICAgICAgICAgICAgaWYgKCFnbG93aW5nRWxlbWVudHMuc29tZSgoZWxlbWVudCkgPT4gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NhbmR5LWlkJykgfHwgJzAnLCAxMCkgPT09IGNhbmR5SWRcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHRhcmdldCBlbGVtZW50IG9ubHkgaWYgaXRzIGNhbmR5LWlkIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gc3F1YXJlQmVpbmdEcmFnZ2VkKSB7XG4gICAgICAgICAgICAgICAgc2V0U3F1YXJlU3RhdGUocHJldlN0YXRlID0+KHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucHJldlN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBnbG93aW5nRWxlbWVudHM6IFsuLi5wcmV2U3RhdGUuZ2xvd2luZ0VsZW1lbnRzLCB0YXJnZXRdXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHNldEdsb3dpbmdFbGVtZW50cygocHJldkVsZW1lbnRzKSA9PiBbLi4ucHJldkVsZW1lbnRzLCB0YXJnZXRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoZ2xvd2luZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlclBvc2l0aW9uICE9PSBzcXVhcmVCZWluZ0RyYWdnZWRJbml0aWFsUG9zaXRpb24pIHtcbiAgICBcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkRWxlbWVudHMgPSBnbG93aW5nRWxlbWVudHMuc2xpY2UoMSk7IC8vIFJlbW92ZSB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIGdsb3dpbmdFbGVtZW50c1swXS5zdHlsZS5ib3hTaGFkb3cgPSAnJzsgLy8gUmVtb3ZlIGdsb3cgZWZmZWN0IGZyb20gdGhlIGxhc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIHNldFNxdWFyZVN0YXRlKHByZXZTdGF0ZSA9Pih7XG4gICAgICAgICAgICAgICAgICAgIC4uLnByZXZTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2xvd2luZ0VsZW1lbnRzOiB1cGRhdGVkRWxlbWVudHNcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNxdWFyZUJlaW5nRHJhZ2dlZE92ZXJQb3NpdGlvbiAhPT0gc3F1YXJlQmVpbmdEcmFnZ2VkSW5pdGlhbFBvc2l0aW9uXG4gICAgICAgICAgICAgICAgJiYgKHRhcmdldCAhPT0gc3F1YXJlQmVpbmdEcmFnZ2VkKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmJveFNoYWRvdyA9IGlzQmVpbmdEcmFnZ2VkID8gXCIwIDAgMTBweCAjZmZmZmUwLCAwIDAgMjBweCAjZmZmZmUwLCAwIDAgMzBweCAjZmZmZmUwLCAwIDAgNDBweCAjZmZmZmUwXCIgOiAnJzsgLy8gQXBwbHkgZ2xvdyBlZmZlY3RcbiAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmJveFNoYWRvdyA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0JlaW5nRHJhZ2dlZCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5ib3hTaGFkb3cgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHNxdWFyZUJlaW5nRHJhZ2dlZCkge1xuICAgICAgICAgICAgICAgIGlmKGdsb3dpbmdFbGVtZW50c1swXSkge1xuICAgICAgICAgICAgICAgIGdsb3dpbmdFbGVtZW50c1swXS5zdHlsZS5ib3hTaGFkb3cgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBlbHNlIGlmIChjYW5keUlkICE9PSBpbml0aWFsU3F1YXJlKSB7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUuYm94U2hhZG93ID0gXCJcIjsgLy8gUmVtb3ZlIGdsb3cgZWZmZWN0IGlmIG5vdCBhZGphY2VudFxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IFwiXCI7IC8vIFJlc2V0IHNpemVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUuYm94U2hhZG93ID0gXCIwIDAgMTBweCAjMDBmZmZmLCAwIDAgMjBweCAjMDBmZmZmLCAwIDAgMzBweCAjMDBmZmZmLCAwIDAgNDBweCAjMDBmZmZmXCI7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBkaXNwYXRjaChkcmFnT3Zlcih7IHBvc2l0aW9uWDogY2FuZHlJZCAlIDgsIHBvc2l0aW9uWTogTWF0aC5mbG9vcihjYW5keUlkIC8gOCkgfSkpO1xuICAgICAgICAgICAgc2V0U3F1YXJlU3RhdGUocHJldlN0YXRlPT4oe1xuICAgICAgICAgICAgLi4ucHJldlN0YXRlLFxuICAgICAgICAgICAgZHJhZ2dlZE92ZXJTcXVhcmU6dGFyZ2V0XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZVRvdWNoRW5kID0gKGU6IFJlYWN0LlRvdWNoRXZlbnQ8SFRNTEltYWdlRWxlbWVudD4pID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGRlZmF1bHQgdG91Y2ggYmVoYXZpb3JcbiAgICAgICAgY29uc3QgdG91Y2ggPSBlLmNoYW5nZWRUb3VjaGVzWzBdOyAvLyBHZXQgdGhlIGZpcnN0IHRvdWNoIHBvaW50XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7IC8vIEdldCB0aGUgZWxlbWVudCB1bmRlciB0aGUgdG91Y2hcbiAgICBcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHsgLy8gRW5zdXJlIGl0J3MgYW4gaW1hZ2UgZWxlbWVudFxuICAgIFxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmJveFNoYWRvdyA9IFwiXCI7IC8vIFJlbW92ZSB0aGUgYm94IHNoYWRvd1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IFwiXCI7IC8vIEdyb3cgdGhlIHNpemUgYnkgMTAlICAgIGNvbnNvbGUubG9nKCdpdCB3b3JrcycsIGlzQmVpbmdEcmFnZ2VkKVxuICAgIFxuICAgICAgICAgICAgY29uc3QgdG91Y2hUYXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCwgZS5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgICAgIGlmICh0b3VjaFRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmJveFNoYWRvdyA9IFwiXCI7IC8vIFJlbW92ZSB0aGUgYm94IHNoYWRvd1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IFwiXCI7IC8vIEdyb3cgdGhlIHNpemUgYnkgMTAlICAgIGNvbnNvbGUubG9nKCdpdCB3b3JrcycsIGlzQmVpbmdEcmFnZ2VkKSAgICAgIGRpc3BhdGNoKGRyYWdEcm9wKHRvdWNoVGFyZ2V0KSk7XG4gICAgICAgICAgICBkaXNwYXRjaChkcmFnRHJvcCh0b3VjaFRhcmdldCkpO1xuICAgICAgICAgICAgc2V0U3F1YXJlU3RhdGUocHJldlN0YXRlPT4oe1xuICAgICAgICAgICAgICAgIC4uLnByZXZTdGF0ZSxcbiAgICAgICAgICAgICAgICBpc0JlaW5nRHJhZ2dlZDpmYWxzZX0pKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIChzcXVhcmVCZWluZ0RyYWdnZWQgYXMgYW55KS5zdHlsZS5ib3hTaGFkb3cgPSAnJztcbiAgICAgICAgICAgIChzcXVhcmVCZWluZ0RyYWdnZWQgYXMgYW55KS5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICBcbiAgICAgICAgICAgIGdsb3dpbmdFbGVtZW50c1swXS5zdHlsZS5ib3hTaGFkb3cgPSBcIlwiOyAvLyBSZW1vdmUgdGhlIGJveCBzaGFkb3dcbiAgICAgICAgICAgIGdsb3dpbmdFbGVtZW50c1swXS5zdHlsZS50cmFuc2Zvcm0gPSBcIlwiOyAvLyBHcm93IHRoZSBzaXplIGJ5IDEwJVxuICAgICAgICAgICAgZGlzcGF0Y2goZHJhZ0VuZCgpKTtcbiAgICAgICAgICAgIHNldFNxdWFyZVN0YXRlKHByZXZTdGF0ZT0+KHtcbiAgICAgICAgICAgIC4uLnByZXZTdGF0ZSxcbiAgICAgICAgICAgIGlzQmVpbmdEcmFnZ2VkOmZhbHNlfSkpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaGFuZGxlUG9pbnRlckxlYXZlID0gKGU6IFJlYWN0LlBvaW50ZXJFdmVudDxIVE1MSW1hZ2VFbGVtZW50PikgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCB0b3VjaCBiZWhhdmlvclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW1hZ2VFbGVtZW50O1xuICAgICAgICB0YXJnZXQuc3R5bGUuYm94U2hhZG93ID0gXCJcIjsgLy8gUmVtb3ZlIHRoZSBib3ggc2hhZG93XG4gICAgICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBcIlwiOyAvLyBHcm93IHRoZSBzaXplIGJ5IDEwJSAgICBjb25zb2xlLmxvZygnaXQgd29ya3MnLCBpc0JlaW5nRHJhZ2dlZCkgICAgICBkaXNwYXRjaChkcmFnRHJvcCh0b3VjaFRhcmdldCkpO1xuICAgICAgICBpZihnbG93aW5nRWxlbWVudHNbMF0pIHtcbiAgICAgICAgZ2xvd2luZ0VsZW1lbnRzWzBdLnN0eWxlLmJveFNoYWRvdyA9IFwiXCI7IC8vIFJlbW92ZSB0aGUgYm94IHNoYWRvd1xuICAgICAgICBnbG93aW5nRWxlbWVudHNbMF0uc3R5bGUudHJhbnNmb3JtID0gXCJcIjsgLy8gR3JvdyB0aGUgc2l6ZSBieSAxMCVcbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaChkcmFnRW5kKCkpO1xuICAgICAgICBzZXRTcXVhcmVTdGF0ZShwcmV2U3RhdGU9Pih7XG4gICAgICAgICAgICAuLi5wcmV2U3RhdGUsXG4gICAgICAgICAgICBpc0JlaW5nRHJhZ2dlZDpmYWxzZX0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgIGhhbmRsZVRvdWNoU3RhcnQsIFxuICAgICAgICBoYW5kbGVUb3VjaE1vdmUsIFxuICAgICAgICBoYW5kbGVUb3VjaEVuZCwgXG4gICAgICAgIGhhbmRsZVBvaW50ZXJMZWF2ZX07XG5cbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJkcmFnRHJvcCIsImRyYWdFbmQiLCJkcmFnU3RhcnQiLCJkcmFnT3ZlciIsInVzZUFwcERpc3BhdGNoIiwidXNlQXBwU2VsZWN0b3IiLCJkZWJvdW5jZSIsInVzZVRvdWNoSGFuZGxlcnMiLCJzZXRTcXVhcmVTdGF0ZSIsImlzQmVpbmdEcmFnZ2VkIiwiaW5pdGlhbFNxdWFyZSIsImdsb3dpbmdFbGVtZW50cyIsInNxdWFyZUJlaW5nRHJhZ2dlZCIsInN0YXRlIiwiY2FuZHlDcnVzaCIsInNxdWFyZUJlaW5nRHJhZ2dlZE92ZXIiLCJkaXNwYXRjaCIsImhhbmRsZVRvdWNoU3RhcnQiLCJlIiwicHJldlN0YXRlIiwidG91Y2giLCJjaGFuZ2VkVG91Y2hlcyIsInRhcmdldCIsImRvY3VtZW50IiwiZWxlbWVudEZyb21Qb2ludCIsImNsaWVudFgiLCJjbGllbnRZIiwiSFRNTEltYWdlRWxlbWVudCIsImNhbmR5SWQiLCJwYXJzZUludCIsImdldEF0dHJpYnV0ZSIsInN0eWxlIiwiYm94U2hhZG93IiwidHJhbnNmb3JtIiwiaGFuZGxlRGVib3VuY2VkVG91Y2hNb3ZlIiwibGFzdFRvdWNoWCIsImxhc3RUb3VjaFkiLCJsYXN0VG91Y2hUaW1lIiwidGhyZXNob2xkIiwiaGFuZGxlVG91Y2hNb3ZlIiwidG91Y2hYIiwidG91Y2hZIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwidGltZURpZmYiLCJkaXN0YW5jZVgiLCJNYXRoIiwiYWJzIiwiZGlzdGFuY2VZIiwiaXNGYXN0RHJhZyIsImNhbmR5SW1hZ2VzIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJpbWciLCJzcXVhcmVCZWluZ0RyYWdnZWRJbml0aWFsUG9zaXRpb24iLCJwb3NpdGlvblgiLCJwb3NpdGlvblkiLCJzcXVhcmVCZWluZ0RyYWdnZWRPdmVyUG9zaXRpb24iLCJzb21lIiwiZWxlbWVudCIsImxlbmd0aCIsInVwZGF0ZWRFbGVtZW50cyIsInNsaWNlIiwiZmxvb3IiLCJkcmFnZ2VkT3ZlclNxdWFyZSIsImhhbmRsZVRvdWNoRW5kIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaFRhcmdldCIsImhhbmRsZVBvaW50ZXJMZWF2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/user-actions/touchEvents.ts\n"));

/***/ })

});