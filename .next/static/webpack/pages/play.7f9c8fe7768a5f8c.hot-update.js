"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/play",{

/***/ "./src/utils/user-actions/mouseEvents.ts":
/*!***********************************************!*\
  !*** ./src/utils/user-actions/mouseEvents.ts ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMouseHandlers: function() { return /* binding */ useMouseHandlers; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _store_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../store/index */ \"./src/store/index.ts\");\n/* harmony import */ var _store_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../store/hooks */ \"./src/store/hooks.ts\");\n/* harmony import */ var use_sound__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! use-sound */ \"./node_modules/use-sound/dist/use-sound.esm.js\");\n\n\n\n\nfunction useMouseHandlers(setSquareState, isBeingDragged, initialSquare, draggedOverSquare, playedSoundForElement) {\n    // redux state extraction \n    const squareBeingDragged = (0,_store_hooks__WEBPACK_IMPORTED_MODULE_2__.useAppSelector)((state)=>state.candyCrush.squareBeingDragged);\n    const squareBeingDraggedOver = (0,_store_hooks__WEBPACK_IMPORTED_MODULE_2__.useAppSelector)((state)=>state.candyCrush.squareBeingDraggedOver);\n    const [playHover, exposedData] = (0,use_sound__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\"hover-over.mp3\");\n    const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [soundCooldown, setSoundCooldown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [previousMouseX, setPreviousMouseX] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [previousMouseY, setPreviousMouseY] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const dispatch = (0,_store_hooks__WEBPACK_IMPORTED_MODULE_2__.useAppDispatch)();\n    // event when user selects an element to drag\n    const handleMouseDragStart = (e)=>{\n        setSquareState((prevState)=>({\n                ...prevState,\n                isBeingDragged: true\n            }));\n        const target = e.target;\n        const candyId = parseInt(target.getAttribute(\"candy-id\") || \"0\", 10);\n        target.style.boxShadow = \"0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff\";\n        target.style.transform = \"scale(1.3)\"; // Grow the size by 10%\n        setSquareState((prevSquareState)=>({\n                ...prevSquareState,\n                initialSquare: candyId\n            }));\n        // Add the position of the initial element being dragged to the set\n        playedSoundForElement.add(candyId);\n        console.log(\"played for elem\", playedSoundForElement);\n        dispatch((0,_store_index__WEBPACK_IMPORTED_MODULE_1__.dragStart)(e.target));\n        console.log(\"sd\"); // Logs the updated value within the callback\n    };\n    // event when user drags an element \n    const handleMouseDragOver = (e)=>{\n        e.preventDefault();\n        setSquareState((prevState)=>({\n                ...prevState,\n                isBeingDragged: true\n            }));\n        const target = e.target;\n        const candyId = parseInt(target.getAttribute(\"candy-id\") || \"0\", 10);\n        const squareBeingDraggedInitialPosition = squareBeingDragged.getAttribute(\"candy-id\");\n        const positionX = squareBeingDraggedOver === null || squareBeingDraggedOver === void 0 ? void 0 : squareBeingDraggedOver.positionX;\n        const positionY = squareBeingDraggedOver === null || squareBeingDraggedOver === void 0 ? void 0 : squareBeingDraggedOver.positionY;\n        const squareBeingDraggedOverPosition = positionY * 8 + positionX;\n        setPlaying(true);\n        // restrict glowing elements to adjacent from selected element being dragged\n        if (Math.abs(squareBeingDraggedInitialPosition - squareBeingDraggedOverPosition) === 1 || // check horizontal adjacency\n        Math.abs(squareBeingDraggedInitialPosition - squareBeingDraggedOverPosition) === 8 || // Check for vertical adjacency\n        Math.abs(squareBeingDraggedInitialPosition - squareBeingDraggedOverPosition) === 7 || // Check for diagonal adjacency (top-left/bottom-right)\n        Math.abs(squareBeingDraggedInitialPosition - squareBeingDraggedOverPosition) === 9 // Check for diagonal adjacency (top-right/bottom-left)\n        ) {\n            console.log(candyId, initialSquare);\n            if (candyId !== initialSquare) {\n                if (!playedSoundForElement.has(squareBeingDraggedOverPosition) && !soundCooldown && !playing) {\n                    playHover(); // Play the sound immediately\n                    playedSoundForElement.add(squareBeingDraggedOverPosition);\n                    setSoundCooldown(true); // Start the cooldown\n                }\n                setTimeout(()=>{\n                    setSoundCooldown(false); // End the cooldown after the delay\n                }, 200); // Adjust the delay as needed\n            }\n            if (squareBeingDraggedOverPosition !== squareBeingDraggedInitialPosition) {\n                target.style.boxShadow = isBeingDragged ? \"0 0 10px #ffffe0, 0 0 20px #ffffe0, 0 0 30px #ffffe0, 0 0 40px #ffffe0\" : \"\"; // Apply glow effect\n            } else if (squareBeingDraggedOverPosition === squareBeingDraggedInitialPosition) {\n                target.style.boxShadow = \"\";\n            } else {\n                target.style.boxShadow = \"\";\n            }\n        } else if (candyId !== initialSquare) {\n            target.style.boxShadow = \"\"; // Remove glow effect if not adjacent\n            target.style.transform = \"\"; // Reset size\n        } else {\n            target.style.boxShadow = \"0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff, 0 0 40px #00ffff\";\n        }\n        dispatch((0,_store_index__WEBPACK_IMPORTED_MODULE_1__.dragOver)({\n            positionX: candyId % 8,\n            positionY: Math.floor(candyId / 8)\n        }));\n        setSquareState((prevSquareState)=>({\n                ...prevSquareState,\n                draggedOverSquare: target\n            }));\n    };\n    // when the user drops the dragged element onto an invalid move\n    const handleMouseDragLeave = (e)=>{\n        const target = e.target;\n        const candyId = parseInt(target.getAttribute(\"candy-id\") || \"0\", 10);\n        const positionX = squareBeingDraggedOver === null || squareBeingDraggedOver === void 0 ? void 0 : squareBeingDraggedOver.positionX;\n        const positionY = squareBeingDraggedOver === null || squareBeingDraggedOver === void 0 ? void 0 : squareBeingDraggedOver.positionY;\n        const squareBeingDraggedOverPosition = positionY * 8 + positionX;\n        setPlaying(false);\n        playedSoundForElement.delete(squareBeingDraggedOverPosition);\n        //exposedData.sound.fade(0.0, .5, 300);\n        if (draggedOverSquare instanceof HTMLImageElement) {\n            draggedOverSquare.style.boxShadow = \" \"; // Remove the glow effect from the dragged over square\n        }\n        if (candyId !== initialSquare) {\n            // Only remove the glow effect if it's not the initial square\n            target.style.boxShadow = \"\";\n            target.style.transform = \"\";\n        }\n        dispatch((0,_store_index__WEBPACK_IMPORTED_MODULE_1__.dragEnd)());\n        setSquareState((prevState)=>({\n                ...prevState,\n                isBeingDragged: false\n            }));\n    };\n    // when user drops onto another valid tile with invalid result\n    const handleMouseDrop = (e)=>{\n        const target = e.target;\n        target.style.boxShadow = \"\";\n        dispatch((0,_store_index__WEBPACK_IMPORTED_MODULE_1__.dragDrop)(e.target));\n    };\n    // when user releases the dragged element \n    const handleMouseDragEnd = (e)=>{\n        const target = e.target;\n        target.style.boxShadow = \"\"; // Remove the box shadow\n        target.style.transform = \"\"; // Reset the size\n        setSquareState((prevState)=>({\n                ...prevState,\n                initialSquare: 0\n            })); // reset initial square\n        dispatch((0,_store_index__WEBPACK_IMPORTED_MODULE_1__.dragEnd)());\n        setSquareState((prevState)=>({\n                ...prevState,\n                isBeingDragged: false\n            }));\n    };\n    return {\n        handleMouseDragStart,\n        handleMouseDragOver,\n        handleMouseDragLeave,\n        handleMouseDrop,\n        handleMouseDragEnd\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy91c2VyLWFjdGlvbnMvbW91c2VFdmVudHMudHM/M2RhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHt1c2VTdGF0ZX0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZHJhZ0Ryb3AsIGRyYWdFbmQsIGRyYWdTdGFydCwgZHJhZ092ZXIgfSBmcm9tIFwiLi4vLi4vc3RvcmUvaW5kZXhcIjtcbmltcG9ydCB7IHVzZUFwcERpc3BhdGNoLCB1c2VBcHBTZWxlY3RvciB9IGZyb20gXCIuLi8uLi9zdG9yZS9ob29rc1wiO1xuaW1wb3J0IHVzZVNvdW5kIGZyb20gJ3VzZS1zb3VuZCc7XG5cbmludGVyZmFjZSBTcXVhcmVTdGF0ZSB7XG4gICAgaW5pdGlhbFNxdWFyZTogbnVtYmVyO1xuICAgIGRyYWdnZWRPdmVyU3F1YXJlOiBhbnk7XG4gICAgaXNCZWluZ0RyYWdnZWQ6IGJvb2xlYW47XG4gICAgZ2xvd2luZ0VsZW1lbnRzOiBIVE1MSW1hZ2VFbGVtZW50W107XG4gICAgcGxheWVkU291bmRGb3JFbGVtZW50OiBTZXQ8bnVtYmVyPjtcbiAgICB9O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlTW91c2VIYW5kbGVycyhcbiAgICBzZXRTcXVhcmVTdGF0ZTogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248U3F1YXJlU3RhdGU+PixcbiAgICBpc0JlaW5nRHJhZ2dlZDogYm9vbGVhbixcbiAgICBpbml0aWFsU3F1YXJlOiBudW1iZXIsXG4gICAgZHJhZ2dlZE92ZXJTcXVhcmU6IGFueSxcbiAgICBwbGF5ZWRTb3VuZEZvckVsZW1lbnQ6IGFueSxcblxuKSB7XG5cbiAgICAvLyByZWR1eCBzdGF0ZSBleHRyYWN0aW9uIFxuICAgIGNvbnN0IHNxdWFyZUJlaW5nRHJhZ2dlZCA9IHVzZUFwcFNlbGVjdG9yKChzdGF0ZSkgPT4gc3RhdGUuY2FuZHlDcnVzaC5zcXVhcmVCZWluZ0RyYWdnZWQpO1xuICAgIGNvbnN0IHNxdWFyZUJlaW5nRHJhZ2dlZE92ZXIgPSB1c2VBcHBTZWxlY3Rvcigoc3RhdGUpID0+IHN0YXRlLmNhbmR5Q3J1c2guc3F1YXJlQmVpbmdEcmFnZ2VkT3Zlcik7XG5cbiAgICBjb25zdCBbcGxheUhvdmVyLCBleHBvc2VkRGF0YV0gPSB1c2VTb3VuZCgnaG92ZXItb3Zlci5tcDMnKTtcbiAgICBjb25zdCBbcGxheWluZywgc2V0UGxheWluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3NvdW5kQ29vbGRvd24sIHNldFNvdW5kQ29vbGRvd25dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtwcmV2aW91c01vdXNlWCwgc2V0UHJldmlvdXNNb3VzZVhdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3ByZXZpb3VzTW91c2VZLCBzZXRQcmV2aW91c01vdXNlWV0gPSB1c2VTdGF0ZSgwKTtcblxuICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlQXBwRGlzcGF0Y2goKTtcblxuICAgIC8vIGV2ZW50IHdoZW4gdXNlciBzZWxlY3RzIGFuIGVsZW1lbnQgdG8gZHJhZ1xuICAgIGNvbnN0IGhhbmRsZU1vdXNlRHJhZ1N0YXJ0ID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEltYWdlRWxlbWVudD4pID0+IHtcbiAgICAgICAgc2V0U3F1YXJlU3RhdGUocHJldlN0YXRlID0+ICh7XG4gICAgICAgICAgICAuLi5wcmV2U3RhdGUsXG4gICAgICAgICAgICBpc0JlaW5nRHJhZ2dlZDogdHJ1ZVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTEltYWdlRWxlbWVudDtcbiAgICAgICAgY29uc3QgY2FuZHlJZCA9IHBhcnNlSW50KHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2NhbmR5LWlkJykgfHwgJzAnLCAxMCk7XG4gICAgICAgIHRhcmdldC5zdHlsZS5ib3hTaGFkb3cgPSBcIjAgMCAxMHB4ICMwMGZmZmYsIDAgMCAyMHB4ICMwMGZmZmYsIDAgMCAzMHB4ICMwMGZmZmYsIDAgMCA0MHB4ICMwMGZmZmZcIjtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoMS4zKVwiOyAvLyBHcm93IHRoZSBzaXplIGJ5IDEwJVxuXG4gICAgICAgIHNldFNxdWFyZVN0YXRlKChwcmV2U3F1YXJlU3RhdGUpID0+ICh7XG4gICAgICAgICAgICAuLi5wcmV2U3F1YXJlU3RhdGUsXG4gICAgICAgICAgICBpbml0aWFsU3F1YXJlOiBjYW5keUlkXG4gICAgICAgIH0pKVxuXG4gICAgICAgIC8vIEFkZCB0aGUgcG9zaXRpb24gb2YgdGhlIGluaXRpYWwgZWxlbWVudCBiZWluZyBkcmFnZ2VkIHRvIHRoZSBzZXRcbiAgICAgICAgcGxheWVkU291bmRGb3JFbGVtZW50LmFkZChjYW5keUlkKTtcblxuICAgICAgICBjb25zb2xlLmxvZygncGxheWVkIGZvciBlbGVtJyxwbGF5ZWRTb3VuZEZvckVsZW1lbnQpXG4gICAgICAgIFxuICAgICAgICBkaXNwYXRjaChkcmFnU3RhcnQoZS50YXJnZXQpKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3NkJyk7IC8vIExvZ3MgdGhlIHVwZGF0ZWQgdmFsdWUgd2l0aGluIHRoZSBjYWxsYmFja1xuICAgIH07XG5cbiAgICAvLyBldmVudCB3aGVuIHVzZXIgZHJhZ3MgYW4gZWxlbWVudCBcbiAgICBjb25zdCBoYW5kbGVNb3VzZURyYWdPdmVyID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEltYWdlRWxlbWVudD4pID0+IHtcblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHNldFNxdWFyZVN0YXRlKHByZXZTdGF0ZSA9PiAoe1xuICAgICAgLi4ucHJldlN0YXRlLFxuICAgICAgaXNCZWluZ0RyYWdnZWQ6IHRydWVcbiAgICAgIH0pKTtcblxuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbWFnZUVsZW1lbnQ7XG4gICAgY29uc3QgY2FuZHlJZCA9IHBhcnNlSW50KHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2NhbmR5LWlkJykgfHwgJzAnLCAxMCk7XG4gICAgXG4gICAgY29uc3Qgc3F1YXJlQmVpbmdEcmFnZ2VkSW5pdGlhbFBvc2l0aW9uID0gKHNxdWFyZUJlaW5nRHJhZ2dlZCBhcyBhbnkpLmdldEF0dHJpYnV0ZSgnY2FuZHktaWQnKTtcblxuICAgIGNvbnN0IHBvc2l0aW9uWCA9IChzcXVhcmVCZWluZ0RyYWdnZWRPdmVyIGFzIGFueSk/LnBvc2l0aW9uWDtcbiAgICBjb25zdCBwb3NpdGlvblkgPSAoc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlciBhcyBhbnkpPy5wb3NpdGlvblk7XG4gICAgY29uc3Qgc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlclBvc2l0aW9uID0gcG9zaXRpb25ZICogOCArIHBvc2l0aW9uWDtcblxuICAgIHNldFBsYXlpbmcodHJ1ZSk7XG5cbiAgICAvLyByZXN0cmljdCBnbG93aW5nIGVsZW1lbnRzIHRvIGFkamFjZW50IGZyb20gc2VsZWN0ZWQgZWxlbWVudCBiZWluZyBkcmFnZ2VkXG4gICAgaWYgKFxuICAgICAgTWF0aC5hYnMoc3F1YXJlQmVpbmdEcmFnZ2VkSW5pdGlhbFBvc2l0aW9uIC0gc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlclBvc2l0aW9uKSA9PT0gMSB8fCAvLyBjaGVjayBob3Jpem9udGFsIGFkamFjZW5jeVxuICAgICAgTWF0aC5hYnMoc3F1YXJlQmVpbmdEcmFnZ2VkSW5pdGlhbFBvc2l0aW9uIC0gc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlclBvc2l0aW9uKSA9PT0gOCB8fCAvLyBDaGVjayBmb3IgdmVydGljYWwgYWRqYWNlbmN5XG4gICAgICBNYXRoLmFicyhzcXVhcmVCZWluZ0RyYWdnZWRJbml0aWFsUG9zaXRpb24gLSBzcXVhcmVCZWluZ0RyYWdnZWRPdmVyUG9zaXRpb24pID09PSA3IHx8IC8vIENoZWNrIGZvciBkaWFnb25hbCBhZGphY2VuY3kgKHRvcC1sZWZ0L2JvdHRvbS1yaWdodClcbiAgICAgIE1hdGguYWJzKHNxdWFyZUJlaW5nRHJhZ2dlZEluaXRpYWxQb3NpdGlvbiAtIHNxdWFyZUJlaW5nRHJhZ2dlZE92ZXJQb3NpdGlvbikgPT09IDkgLy8gQ2hlY2sgZm9yIGRpYWdvbmFsIGFkamFjZW5jeSAodG9wLXJpZ2h0L2JvdHRvbS1sZWZ0KVxuICAgICkge1xuXG4gICAgICBjb25zb2xlLmxvZyhjYW5keUlkLCBpbml0aWFsU3F1YXJlKVxuXG4gICAgICBpZiAoY2FuZHlJZCAhPT0gaW5pdGlhbFNxdWFyZSkge1xuICAgIGlmICghcGxheWVkU291bmRGb3JFbGVtZW50LmhhcyhzcXVhcmVCZWluZ0RyYWdnZWRPdmVyUG9zaXRpb24pIFxuICAgICAgJiYgIXNvdW5kQ29vbGRvd24gJiYgIXBsYXlpbmcpIHtcbiAgICAgIHBsYXlIb3ZlcigpOyAvLyBQbGF5IHRoZSBzb3VuZCBpbW1lZGlhdGVseVxuXG4gICAgICBwbGF5ZWRTb3VuZEZvckVsZW1lbnQuYWRkKHNxdWFyZUJlaW5nRHJhZ2dlZE92ZXJQb3NpdGlvbik7XG4gICAgICBzZXRTb3VuZENvb2xkb3duKHRydWUpOyAvLyBTdGFydCB0aGUgY29vbGRvd25cbiAgICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldFNvdW5kQ29vbGRvd24oZmFsc2UpOyAvLyBFbmQgdGhlIGNvb2xkb3duIGFmdGVyIHRoZSBkZWxheVxuICAgICAgfSwgMjAwKTsgLy8gQWRqdXN0IHRoZSBkZWxheSBhcyBuZWVkZWRcbiAgICB9XG4gICAgICAgICAgXG4gICAgICBpZiAoc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlclBvc2l0aW9uICE9PSBzcXVhcmVCZWluZ0RyYWdnZWRJbml0aWFsUG9zaXRpb24pIHtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLmJveFNoYWRvdyA9IGlzQmVpbmdEcmFnZ2VkID8gXCIwIDAgMTBweCAjZmZmZmUwLCAwIDAgMjBweCAjZmZmZmUwLCAwIDAgMzBweCAjZmZmZmUwLCAwIDAgNDBweCAjZmZmZmUwXCIgOiAnJzsgLy8gQXBwbHkgZ2xvdyBlZmZlY3RcbiAgICAgIH0gZWxzZSBpZihzcXVhcmVCZWluZ0RyYWdnZWRPdmVyUG9zaXRpb24gPT09IHNxdWFyZUJlaW5nRHJhZ2dlZEluaXRpYWxQb3NpdGlvbikge1xuICAgICAgdGFyZ2V0LnN0eWxlLmJveFNoYWRvdyA9IFwiXCI7XG4gICAgICB9XG4gICAgICBlbHNlIHsgIFxuICAgICAgdGFyZ2V0LnN0eWxlLmJveFNoYWRvdyA9IFwiXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxzZSBpZiAoY2FuZHlJZCAhPT0gaW5pdGlhbFNxdWFyZSkge1xuICAgICAgdGFyZ2V0LnN0eWxlLmJveFNoYWRvdyA9IFwiXCI7IC8vIFJlbW92ZSBnbG93IGVmZmVjdCBpZiBub3QgYWRqYWNlbnRcbiAgICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBcIlwiOyAvLyBSZXNldCBzaXplXG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5zdHlsZS5ib3hTaGFkb3cgPSBcIjAgMCAxMHB4ICMwMGZmZmYsIDAgMCAyMHB4ICMwMGZmZmYsIDAgMCAzMHB4ICMwMGZmZmYsIDAgMCA0MHB4ICMwMGZmZmZcIjtcbiAgICAgIFxuICAgIH1cblxuICAgIGRpc3BhdGNoKGRyYWdPdmVyKHsgcG9zaXRpb25YOiBjYW5keUlkICUgOCwgcG9zaXRpb25ZOiBNYXRoLmZsb29yKGNhbmR5SWQgLyA4KSB9KSk7XG4gICAgc2V0U3F1YXJlU3RhdGUoKHByZXZTcXVhcmVTdGF0ZSkgPT4gKHtcbiAgICAgIC4uLnByZXZTcXVhcmVTdGF0ZSxcbiAgICAgIGRyYWdnZWRPdmVyU3F1YXJlOiB0YXJnZXRcbiAgICB9KSlcblxuICB9O1xuXG4gICAgLy8gd2hlbiB0aGUgdXNlciBkcm9wcyB0aGUgZHJhZ2dlZCBlbGVtZW50IG9udG8gYW4gaW52YWxpZCBtb3ZlXG4gICAgY29uc3QgaGFuZGxlTW91c2VEcmFnTGVhdmUgPSAoZTogUmVhY3QuRHJhZ0V2ZW50PEhUTUxJbWFnZUVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbWFnZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNhbmR5SWQgPSBwYXJzZUludCh0YXJnZXQuZ2V0QXR0cmlidXRlKCdjYW5keS1pZCcpIHx8ICcwJywgMTApO1xuXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uWCA9IChzcXVhcmVCZWluZ0RyYWdnZWRPdmVyIGFzIGFueSk/LnBvc2l0aW9uWDtcbiAgICAgICAgY29uc3QgcG9zaXRpb25ZID0gKHNxdWFyZUJlaW5nRHJhZ2dlZE92ZXIgYXMgYW55KT8ucG9zaXRpb25ZO1xuICAgICAgICBjb25zdCBzcXVhcmVCZWluZ0RyYWdnZWRPdmVyUG9zaXRpb24gPSBwb3NpdGlvblkgKiA4ICsgcG9zaXRpb25YO1xuXG5cbiAgICAgICAgc2V0UGxheWluZyhmYWxzZSk7XG4gICAgICAgIHBsYXllZFNvdW5kRm9yRWxlbWVudC5kZWxldGUoc3F1YXJlQmVpbmdEcmFnZ2VkT3ZlclBvc2l0aW9uKVxuICAgICAgICAvL2V4cG9zZWREYXRhLnNvdW5kLmZhZGUoMC4wLCAuNSwgMzAwKTtcbiAgICBcbiAgICAgICAgaWYgKGRyYWdnZWRPdmVyU3F1YXJlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICAgIChkcmFnZ2VkT3ZlclNxdWFyZSBhcyBIVE1MSW1hZ2VFbGVtZW50KS5zdHlsZS5ib3hTaGFkb3cgPSBcIiBcIjsgLy8gUmVtb3ZlIHRoZSBnbG93IGVmZmVjdCBmcm9tIHRoZSBkcmFnZ2VkIG92ZXIgc3F1YXJlXG4gICAgICAgIFxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmIChjYW5keUlkICE9PSBpbml0aWFsU3F1YXJlKSB7XG4gICAgICAgICAgLy8gT25seSByZW1vdmUgdGhlIGdsb3cgZWZmZWN0IGlmIGl0J3Mgbm90IHRoZSBpbml0aWFsIHNxdWFyZVxuICAgICAgICAgIHRhcmdldC5zdHlsZS5ib3hTaGFkb3cgPSBcIlwiO1xuICAgICAgICAgIHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKGRyYWdFbmQoKSk7XG4gICAgICAgIHNldFNxdWFyZVN0YXRlKHByZXZTdGF0ZSA9PiAoe1xuICAgICAgICAgIC4uLnByZXZTdGF0ZSxcbiAgICAgICAgICBpc0JlaW5nRHJhZ2dlZDogZmFsc2VcbiAgICAgICAgfSkpO1xuICAgICAgfTtcblxuICAgIC8vIHdoZW4gdXNlciBkcm9wcyBvbnRvIGFub3RoZXIgdmFsaWQgdGlsZSB3aXRoIGludmFsaWQgcmVzdWx0XG4gICAgY29uc3QgaGFuZGxlTW91c2VEcm9wID0gKGU6IFJlYWN0LkRyYWdFdmVudDxIVE1MSW1hZ2VFbGVtZW50PikgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW1hZ2VFbGVtZW50O1xuICAgICAgICB0YXJnZXQuc3R5bGUuYm94U2hhZG93ID0gXCJcIjtcbiAgICAgICAgZGlzcGF0Y2goZHJhZ0Ryb3AoZS50YXJnZXQpKVxuICB9XG5cbiAgICAvLyB3aGVuIHVzZXIgcmVsZWFzZXMgdGhlIGRyYWdnZWQgZWxlbWVudCBcbiAgICBjb25zdCBoYW5kbGVNb3VzZURyYWdFbmQgPSAoZTogUmVhY3QuRHJhZ0V2ZW50PEhUTUxJbWFnZUVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbWFnZUVsZW1lbnQ7XG4gICAgICAgIHRhcmdldC5zdHlsZS5ib3hTaGFkb3cgPSBcIlwiOyAvLyBSZW1vdmUgdGhlIGJveCBzaGFkb3dcbiAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IFwiXCI7IC8vIFJlc2V0IHRoZSBzaXplXG4gICAgICAgIHNldFNxdWFyZVN0YXRlKHByZXZTdGF0ZSA9PiAoe1xuICAgICAgICAgIC4uLnByZXZTdGF0ZSxcbiAgICAgICAgICBpbml0aWFsU3F1YXJlOiAwXG4gICAgICAgIH0pKTsgLy8gcmVzZXQgaW5pdGlhbCBzcXVhcmVcbiAgICAgICAgZGlzcGF0Y2goZHJhZ0VuZCgpKTtcbiAgICAgICAgc2V0U3F1YXJlU3RhdGUocHJldlN0YXRlID0+ICh7XG4gICAgICAgICAgLi4ucHJldlN0YXRlLFxuICAgICAgICAgIGlzQmVpbmdEcmFnZ2VkOiBmYWxzZVxuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIHsgXG4gICAgICAgIGhhbmRsZU1vdXNlRHJhZ1N0YXJ0LCBcbiAgICAgICAgaGFuZGxlTW91c2VEcmFnT3ZlciwgXG4gICAgICAgIGhhbmRsZU1vdXNlRHJhZ0xlYXZlLCBcbiAgICAgICAgaGFuZGxlTW91c2VEcm9wLFxuICAgICAgICBoYW5kbGVNb3VzZURyYWdFbmQgfTtcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsImRyYWdEcm9wIiwiZHJhZ0VuZCIsImRyYWdTdGFydCIsImRyYWdPdmVyIiwidXNlQXBwRGlzcGF0Y2giLCJ1c2VBcHBTZWxlY3RvciIsInVzZVNvdW5kIiwidXNlTW91c2VIYW5kbGVycyIsInNldFNxdWFyZVN0YXRlIiwiaXNCZWluZ0RyYWdnZWQiLCJpbml0aWFsU3F1YXJlIiwiZHJhZ2dlZE92ZXJTcXVhcmUiLCJwbGF5ZWRTb3VuZEZvckVsZW1lbnQiLCJzcXVhcmVCZWluZ0RyYWdnZWQiLCJzdGF0ZSIsImNhbmR5Q3J1c2giLCJzcXVhcmVCZWluZ0RyYWdnZWRPdmVyIiwicGxheUhvdmVyIiwiZXhwb3NlZERhdGEiLCJwbGF5aW5nIiwic2V0UGxheWluZyIsInNvdW5kQ29vbGRvd24iLCJzZXRTb3VuZENvb2xkb3duIiwicHJldmlvdXNNb3VzZVgiLCJzZXRQcmV2aW91c01vdXNlWCIsInByZXZpb3VzTW91c2VZIiwic2V0UHJldmlvdXNNb3VzZVkiLCJkaXNwYXRjaCIsImhhbmRsZU1vdXNlRHJhZ1N0YXJ0IiwiZSIsInByZXZTdGF0ZSIsInRhcmdldCIsImNhbmR5SWQiLCJwYXJzZUludCIsImdldEF0dHJpYnV0ZSIsInN0eWxlIiwiYm94U2hhZG93IiwidHJhbnNmb3JtIiwicHJldlNxdWFyZVN0YXRlIiwiYWRkIiwiY29uc29sZSIsImxvZyIsImhhbmRsZU1vdXNlRHJhZ092ZXIiLCJwcmV2ZW50RGVmYXVsdCIsInNxdWFyZUJlaW5nRHJhZ2dlZEluaXRpYWxQb3NpdGlvbiIsInBvc2l0aW9uWCIsInBvc2l0aW9uWSIsInNxdWFyZUJlaW5nRHJhZ2dlZE92ZXJQb3NpdGlvbiIsIk1hdGgiLCJhYnMiLCJoYXMiLCJzZXRUaW1lb3V0IiwiZmxvb3IiLCJoYW5kbGVNb3VzZURyYWdMZWF2ZSIsImRlbGV0ZSIsIkhUTUxJbWFnZUVsZW1lbnQiLCJoYW5kbGVNb3VzZURyb3AiLCJoYW5kbGVNb3VzZURyYWdFbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/user-actions/mouseEvents.ts\n"));

/***/ })

});